#----------------------------  FILE INFORMATION  ----------------------------
#
# $URL: http://svn/mfg/probe/automation/perlmenu/trunk/platforms/smg3/imenu.config $
# $Rev: 8314 $
# $Date: 2018-01-29 08:06:55 -0700 (Mon, 29 Jan 2018) $
# $Author: kbremkes $
#
#----------------------------  file information  ----------------------------

#-------------------------------  COPYRIGHT   -------------------------------
#
# © 2007 Micron Technology, Inc. All Rights Reserved.
#
# THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE SECRETS OF
# MICRON TECHNOLOGY, INC. USE, DISCLOSURE, OR REPRODUCTION IS PROHIBITED
# WITHOUT THE PRIOR EXPRESS WRITTEN PERMISSION OF MICRON TECHNOLOGY, INC.
#
#-------------------------------  Copyright   -------------------------------

#------------------------------  EXPORT NOTICE  -----------------------------
#
# These commodities, technology, or software were exported from the
# United States in accordance with the Export Administration Regulations.
# Diversion contrary to U.S. law is prohibited.
#
#------------------------------  export notice  -----------------------------

package PrbCfg;

use File::Path;      # mkpath, rmtree
use File::Slurp;     # read_file, write_file
use File::Copy;

my $PRODUCTION_USER = 'product';
my $PRODUCTION_DIR = '/u/product/job';
#my $PRODUCTION_DIR = '/var/opt/sigsw/jobs/product';
my $SELECTOR_TMPTRAVL_FILE = "/var/tmp/tmptravl.dat";
my $CONFIG_PATH = '/var/tmp';
my $TESTER_INFO_FILE = "$CONFIG_PATH/tester.asc";
my $PROBER_CONTROL = '/u/probe/bin/PROBER_CONTROL';
my $DEVELOPMENT_PROBER_CONTROL = '/u/probe/bin/PROBER_CONTROL_ILLUM_CAL';
#my $GCAP_PROBER_CONTROL = '/u/probe/bin/GCAP_PROBER_CONTROL';
#my $SELECTOR = '/u/probe/bin/selector.pl';
my %SELECTOR_RECIPE;
my $MACRO_PATH = '/u/probe/scripts';
my $TESTENG_UTILITIES = '/u/probe/bin';
my $SYS_INFO = "${TESTENG_UTILITIES}/sys_info";
my $TESTER_DAEMON_CONTROL = "stt_jdctl -s 2>&1";
my $CARD_FILE = '/var/tmp/probecard.asc';
#my $SELECTED_HEADS_MERGE = "${TESTENG_UTILITIES}/selected_heads_merge.pl";
my $CAL_CARD_CONFIG = 1270;  # example is PC-011813
my $CAL_MACRO = 'BCAL';
my $TEST_TYPE;       # special flag indicating if setup is for Engineering debug
my $SYS_INFO_CARD_CONFIG; # sys_info obtains info from PCT, use it to avoid one call
my $MANAGE_SINGLETON = '/bin/ksh /u/probe/scripts/manage_singleton.ksh';

our %SiteConfig = (
    'CardChangeStabilize' => 0,    # control GPC option to perform temperature stabilization if card change is detected
    'TempChangeStabilize' => 0,    # control GPC option to perform temperature stabilization if temperature change is detected
    'DirectedSoak'        => 0,    # control GPC option to perform pin updates
    'DirectedStep'        => 0,    # control GPC option to control stepping
    'DirectedPMI'         => 0,    # control GPC option to control probe mark inspection (currently does not stop on consecutive fails)
    'DirectedClean'       => 0,    # if a valid PCT clean recipe is in place GPC will perform directed clean
);

our %PlatformCfg = (
    'RequiredParams' => {    # don't include 'Job Name'
        'Temperature'       => '^[+-]?\d{1,3}$', # must be integral data
        'PROGRAM_FLOW_FILE' => '^.+', 
        #'PROGRAM_FLOW_FILE' => '^.+\.py$', # should look like a Python script
    },
    'RelSrv'         => '/u/probe/RelSrv/exe',
    'StepTableSrv'   => '/u/probe/RelSrv/move_tables',
    'JobDir'         => '/u/probe/exe_jobs',
    'JobMeta'        => '/u/probe/job_data',
    'MoveTableDir'   => '/u/probe/move_tables',
    'TempDir'        => '/var/tmp',
    'CacheDir'       => '/var/tmp/cache',
    'LogDir'         => '/var/tmp/log',
    'StateFileDir'   => '/var/tmp/log',
    'HeaderDir'      => $PRODUCTION_DIR,
    'MaxTestJobAge'  => '10',  # [days]
    'AttrDir'        => $PRODUCTION_DIR,
    'MaxAttrAge'     => '3',   # [days]
    'SkipAttrLotID'  => 'yes', # yes - attribute files are written directly to 'AttrDir'
    'AttrNoSpaces'   => 'yes', # yes - replace white space with underscore in attr name
    'AttrDelimiter'  => ': ',  # separate attribute keyword from value
    'EtaScript'      => ['/u/probe/scripts/eta.pl'],  # for Run State Transitions
    'PMI_Locs'       => '/u/probe/PMILocs', # For obtaining directed PMI info (symbolic link)
    'PMI_Intervals'  => '/u/probe/log/pmi_intervals.csv',  # for keeping track of lot intervals for PMI's . The PMI_Locs file may specify lot intervals, so it must be local
);

my $GENERIC_PROBER_CONTROL_DELIMITER = ': ';
my $TMPTRAVL_FILE = "$PlatformCfg{'TempDir'}/lot_traveler_h0_front";  # notice this is hardcoded

initialize();  # called on file load

sub initialize {
    if ( !$::OVERRIDE{'PROGRAM_FLOW_FILE'} ) {
          $::OVERRIDE{'PROGRAM_FLOW_FILE'}  = 'tp_main';
    }
    foreach $option (@::ARGV) {
        if (my (undef, $key, $value) = $option =~ /^(-+)?(.+)=(.+)$/) {
            # name value pair options
            print "processing $key=$value\n";
            foreach my $config_key (keys %PlatformCfg) {
                if ($key =~ /^$config_key$/i) {
                    if ($config_key ne 'RequiredParams') {
                        $PlatformCfg{$config_key} = $value;
                    }
                }
            }
            if ($key eq 'PROGRAM_FLOW_FILE') {
                $::OVERRIDE{$key} = $value;
            }
        } else {
            # individual options
            print "processing '$option'\n";
        }
    }
    if ($::OPT{'site'} =~ /BOISE/i) {
        $SiteConfig{'CardChangeStabilize'} = 1;
        $SiteConfig{'TempChangeStabilize'} = 1;
        $SiteConfig{'DirectedSoak'} = 1;
        $SiteConfig{'DirectedStep'} = 1;
        $SiteConfig{'DirectedPMI'} = 1;
        $SiteConfig{'DirectedClean'} = 1;
    } elsif ($::OPT{'site'} =~ /MANASSAS/i) {
        # place site options here
    } elsif ($::OPT{'site'} =~ /TECH_SINGAPORE/i) {
        # place site options here
    } elsif ($::OPT{'site'} =~ /LEHI/i) {
        $SiteConfig{'CardChangeStabilize'} = 1;
        $SiteConfig{'TempChangeStabilize'} = 1;
    }
}

sub backtick_system_command {
    my ($command, $return_stdout) = @_;
    main::notify('debug', "SystemCommand: $command");
    chomp (my $standard_output = `$command`);
    if ($?) {
        return("SystemCommand='$command' Fail: (" . ($? >> 8) . ") $standard_output : $!");
    } elsif ($return_stdout) {
        return($standard_output);
    } else {
        return(undef);
    }
}

sub read_card_id {
    my ($prober) = @_;
    my ($station_num, $card_id, $value, $line);

    # Call a script to read the system configuration information and the probe card NVRAM
    my $sys_info_result;
    if ( $ENV{'HOST'} =~ /smg3|spm3/i ) {
       my $sys_info_command = "/opt/sigsw/el6/bin/sig_sysmgr --tmptravl | grep SSM_EXT_HW_TC_SERIAL_NUMBER_Z00 | awk '{a = \"PASSED\"; print \$NF,a}'";
       $sys_info_result = `$sys_info_command`;
    }
    if ( $ENV{'HOST'} =~ /chrn/i ) {
       my $sys_info_command = "/opt/sigsw/el7/bin/sig_sysmgr --launch_app /opt/sigsw/sl7/bin/diags/tests/probe_card_data --launch_args \"--read --offset 0x10\" --hwmask \"{0:[0]}\" | /usr/bin/grep 'id read'";
       $sys_info_result = `$sys_info_command`;
       # output looks like "[INFO]   id read 18368"
       if ($sys_info_result =~ / id read (\d+)/) {
          $sys_info_result = "PASSED $1";
       }
    }
#    else {
#       my $sys_info_command = "/usr/local/bin/sigpython /usr/local/bin/diags/tests/getProbeCardData.py 2>&1";
#       $sys_info_result = `$sys_info_command`;
#    }
    chomp($sys_info_result);

    main::notify('log', "sys_info_result is: $sys_info_result");
    if ($?) {
       main::notify('warn', "read_card_id ERROR: $sys_info_result");
       return(undef);
    }
    if ($sys_info_result =~ /PASSED/) {
       if ($sys_info_result =~ /(\d+)/ ) {
           my $card_id = $1;
           my $card_name = sprintf("PC-%.6d",$card_id);
           open CARD_FILE, ">$CARD_FILE";
           print CARD_FILE "PROBECARD_ID1: $card_name\n";
           close CARD_FILE;
           return($card_id);
       }
    } elsif (open CARD_FILE, "<$CARD_FILE") {
        while ($line = <CARD_FILE>) {
            chomp $line;
            main::notify('log', "line is: $line");
            if ($line =~ /^PROBECARD_ID\d: PC[-](\d+)/) {
                $card_id = $1;
                main::notify('log', "card_id is: $card_id");
            } elsif (($station_num, $value) = $line =~ /^PROBECARD_CONFIGURATION_BIT(\d+): (\d+)/) {
                $SYS_INFO_CARD_CONFIG = $value;
            }
        }
        close CARD_FILE;
    }
    main::notify('log', "Card is: $card_id");
    if ($card_id) {
        return(int($card_id));
    } else {
        return(undef);
    }
}


sub check_current_state {
    my $common_cfg = File::Spec->catfile(File::Basename::dirname(__FILE__), "common.config");
    eval {
       require $common_cfg;
    };
    # Ideally, we could save this off so that the user could see it in the gui...
    if ($@) {
        return "Error using $common_cfg! Please escalate to PRBSOFT_ONCALL. \n $@";
    }

    # Create some directories needed for normal lot processing should only be needed once.
    if (!-d "/u/product/.summary"){
       mkdir "/u/product/.summary" , 0777;
    }
    if (!-d "/u/product/.summary/.currsum"){
       mkdir "/u/product/.summary/.currsum" , 0777;
    }
    if (!-d "/u/product/.summary/.debris"){
       mkdir "/u/product/.summary/.debris" , 0777;
    }
    if (!-d "/u/product/datalog"){
       mkdir "/u/product/datalog" , 0777;
    }
    if (!-d "/u/product/odfs"){
       mkdir "/u/product/odfs" , 0777;
    }
    if (!-d "/u/product/job"){
       mkdir "/u/product/job" , 0777;
    }
    if ($::OPT{'offline'}) {   # Added this to avoid errors in offline mode
       return (undef);
    }
    if ( $ENV{'HOST'} =~ /chrn/i ) {
       system("/opt/sigsw/el7/bin/sig_clean --all --restart --job-id=product &");
    }
    else {
       system("/opt/sigsw/el6/bin/stt_clean --all --restart --job-id=product &");
    }
    sleep 1;

    my $swr_group_file = File::Spec->catfile( $PlatformCfg{'AttrDir'}, 'swr_split_groups_hd0.dat');
    if ( -e $swr_group_file ) {
        main::notify('debug', "Deleting swr_group_file: $swr_group_file");
        unlink $swr_group_file;
    }

    # add the -custom option to allow this platform config file to
    # modify the menu flow
    #$::OPT{'custom'} = 1;
    # for some reason the call to TESTER_DAEMON_CONTROL returns an error
    # but writes the appropriate information to stdout
    # or stderr depending on what happened
    my $test_job_state = `$TESTER_DAEMON_CONTROL`;
    chomp $test_job_state;
    if ($test_job_state) {
        my $active_port_file = "$CONFIG_PATH/lot_traveler_h0_front.active";
        if (($test_job_state !~ /^unloaded/i) || (-e $active_port_file)) {
            foreach my $prober (sort keys %::LOAD_PORT) {
                $::LOAD_PORT{$prober}{'front'}{'status'} = 'active';
                $::LOAD_PORT{$prober}{'front'}{'lot_id'} = 'UNKNOWN';
                $::LOAD_PORT{$prober}{'front'}{'part_type'} = 'UNKNOWN';
                $::LOAD_PORT{$prober}{'front'}{'quantity'} = 'UNKNOWN';
            }
            if (-e $active_port_file) {
                return("Generic Prober Control is either still running or was shut down improperly.\n");
            }
            return("'$TESTER_DAEMON_CONTROL' returned: $test_job_state\n");
        } else {
            # Test Job is unloaded, this is the expected state
            # when lot is being setup
            return(undef);
        }
    } elsif ($!) {
        return("'$TESTER_DAEMON_CONTROL' returned: $!\n");
    } else {
        return("'$TESTER_DAEMON_CONTROL' returned: $test_job_state\n");
    }
}

sub start_lot_processing {
    my $status;
    if ($status = test_job_pre_start_check()) {
        return($status);
    }
    # for GCAP we need to turn off directed stepping to prevent errors in gpc when trying to step above the wafer...kbremkes
#    if ("CHPN" eq $::PROCESS_STEP{'pid'}) {
#       $PROBER_CONTROL = $GCAP_PROBER_CONTROL;
#    }
    if ( $status = run_autoRXcal() ) {
        return($status);
    }
    &start_probecard_heater();

    # creating a restart script helps in testing by allowing prober control to be restarted without running menu
    my $restart_script = "$PlatformCfg{'TempDir'}/.restart.sh";
    my $program_name = $::RECIPE{PROGRAM_FLOW_FILE} || 'tp_main';

    my $launch_prober_control =
        "$PROBER_CONTROL -temp=$::TEMPERATURE -mt_path=$PlatformCfg{'MoveTableDir'}" .
        " -move_table=$::MOVE_TABLE -attr_path=$PlatformCfg{'AttrDir'}" .
        " -use_slot_selection" .
        " -cfg_path=$CONFIG_PATH -program_name=$program_name";
    if ($::OPT{'offline'}) {
       $launch_prober_control .= " -offline_tester -no_gpib";
    }
    if ( defined($::OPT{'process_type'}) and ("NonProduct" eq $::OPT{'process_type'}) and ("CHPN" eq $::PROCESS_STEP{'pid'})) {
       $launch_prober_control .= " -SKIP_SCRIBE_CHECK -f2l_only";
       $launch_prober_control =~ s/-use_slot_selection//i;
       foreach my $prober (sort keys %::LOAD_PORT) {
          foreach my $cassette (sort keys %{$::LOAD_PORT{$prober}}) {
             $::LOAD_PORT{$prober}{$cassette}{'part_type'} = $::RECIPE{'PART_COMPATIBILITY'};
          }
       }
    }
    if ($::REQUEST and ($::REQUEST eq 'DEBUG')) {
        $TEST_TYPE = 'ENG';
        $launch_prober_control .= " -eng_mode -debug";
    } else {
        $TEST_TYPE = 'NORMAL';
    }
    $launch_prober_control .= " -card_change_stabilize" if $SiteConfig{'CardChangeStabilize'};
    $launch_prober_control .= " -temp_change_stabilize" if $SiteConfig{'TempChangeStabilize'};
    $launch_prober_control .= " -directed_stepping" if $SiteConfig{'DirectedStep'};
    $launch_prober_control .= " -directed_soak" if $SiteConfig{'DirectedSoak'};
    # copy the contents of the local test job into the working job directory
    # using non-portable system command, copied from existing menu
    my $non_portable_system_command = "cp -rp $::LOCAL_JOB_PATH/* $::LOCAL_JOB_PATH/.[a-z0-9A-Z]* $PRODUCTION_DIR 2>/dev/null";
    system($non_portable_system_command);
    foreach my $prober (sort keys %::LOAD_PORT) {
        my $head = CommonCfg::get_head_number($prober);
        my $config_bit = $::PCARD_DATA{$prober}{'bit_config_id'};
        foreach my $cassette (sort keys %{$::LOAD_PORT{$prober}}) {
            if (($::LOAD_PORT{$prober}{$cassette}{'status'} eq 'available') and
                ($::LOAD_PORT{$prober}{$cassette}{'lot_id'})) {
                my $lot_id = $::LOAD_PORT{$prober}{$cassette}{'lot_id'};
                # Only need to write SWR group file for an SWR lot
                if ( $::PRB_LOT_ATTR{$lot_id}{$lot_id}{'SWR FLAG'} eq 'YES') {
                    if ( $error = PrbCfg::write_swr_groupfile( $lot_id, $::PRB_LOT_ATTR{$lot_id}{$lot_id}, $::PRB_WFR_ATTR{$lot_id})) {
                       $any_error .= $any_error ? "\n$error" : $error;
                       return $any_error;
                    }
                 }
                if ($SiteConfig{'DirectedSoak'}) {
                    if ($status = CommonCfg::check_soak_enable($prober, "/var/tmp/lot_traveler_h$head\_$cassette", '/var/tmp')) {
                        return($status);
                    }
                }
                if ($status = CommonCfg::write_probecard_info_file($prober, $cassette, $PlatformCfg{'TempDir'}, $SiteConfig{'DirectedClean'}, 1)) {
                    return($status);
                } elsif ($status = write_tmptravl_file($prober, $cassette)) {
                    return($status);
#                } elsif ($status = selected_heads_merge($TMPTRAVL_FILE)) {
#                    return($status);
                } elsif ($status = CommonCfg::write_scribe_lookup_file($prober, $cassette, $PlatformCfg{'AttrDir'})) {
                    return($status);
                } else {
                    $launch_prober_control .=
                        " -lot${head}=$lot_id" .
                        " -parts_name${head}=$::LOAD_PORT{$prober}{$cassette}{'part_type'}" .
                        " -card_num${head}=$::PCARD_ID{$prober}" .
                        " -card_type${head}=$config_bit" .
                        " -dev_file${head}=$::LOAD_PORT{$prober}{$cassette}{'prober_device_file'}" .
                        " -tester=$::TESTER_ID";
                    if ($prober =~ /(A090)|(A200)|(A300)|(A3EX)$/i) {
                        $launch_prober_control .= " -handler${head}=ACCRETECH_UF";
                    } elsif ($prober =~ /(TP012)$/i) {
                        $launch_prober_control .= " -handler${head}=TEL_PROBER";
                    } elsif ($prober =~ /(PREC)|(PRXL)$/i) {
                        $launch_prober_control .= " -handler${head}=TEL_PRECIO";
                    }
                    # persist lot instructions in local file
                    if ($::GERM_EQUIP_META{$config_bit}{$lot_id}{$::TESTER_ID}{'instructions'}) {
                        my $instruction_file = ($PlatformCfg{'SkipAttrLotID'} =~ m/yes/i) ?
                            "$PlatformCfg{'AttrDir'}/${lot_id}.instruct" :
                            "$PlatformCfg{'AttrDir'}/${lot_id}/${lot_id}.instruct";
                        if (open (INSTRUCT, ">$instruction_file")) {
                            print INSTRUCT "$::GERM_EQUIP_META{$config_bit}{$lot_id}{$::TESTER_ID}{'instructions'}\n";
                            close INSTRUCT;
                        }
                    }
                }
            }
        }
    }
    $launch_prober_control .= " &"; # background the start command
    if (open (RESTART_SCRIPT, ">${restart_script}")) {
        print RESTART_SCRIPT "$launch_prober_control\n";
        close(RESTART_SCRIPT);
        chmod(0777, $restart_script);
    }
    system($launch_prober_control);
    return(undef);
}

sub additional_header {
    my ($prober, $cassette) = @_;
    # no additional header information
    # data will be added to tmptravl later
    return(undef);
}

sub write_tmptravl_file {
    my ($prober, $cassette) = @_;
    my $head = CommonCfg::get_head_number($prober);
    my $handler = $head + 1;  # one based
    my $num_waf = $::LOAD_PORT{$prober}{$cassette}{trend} ? $::LOAD_PORT{$prober}{$cassette}{trend} : $::LOAD_PORT{$prober}{$cassette}{quantity};
    # try to determine how many sites are available on this probecard
    my $config_bit = $::PCARD_DATA{$prober}{'bit_config_id'};
    my $lot_id = $::LOAD_PORT{$prober}{$cassette}{'lot_id'};
    my $additional_information =
        "HEADA: $::ET_ITEMS{$::TESTER_ID}{'HEADA'}{'value'}\n" .
        "MOVE_TABLE_NAME: $::MOVE_TABLE\n" .
        "PROD_FILE: $::LOAD_PORT{$prober}{$cassette}{'prober_device_file'}\n" .
        "OPERATOR_NAME: $::OPERATOR_NAME\n" .
        "PROGRAM_FLOW_FILE: $::RECIPE{PROGRAM_FLOW_FILE}\n" .
        "TEMP: $::TEMPERATURE\n" .
        "TEMPERATURE: $::TEMPERATURE\n" .
        "TRACKING_STEP: $::STEP_NAME\n" .
        "TEST_TYPE: $TEST_TYPE\n" .
        "LOT_DESIGNATORS: $::PRB_LOT_ATTR{$lot_id}{$lot_id}{'FAB DESIGNATOR CODE'}\n" .
        "WAFERMAP_MIN_X: $::MOVE_TABLE_INFO{$config_bit}{'min_x'}\n" .
        "WAFERMAP_MAX_X: $::MOVE_TABLE_INFO{$config_bit}{'max_x'}\n" .
        "WAFERMAP_MIN_Y: $::MOVE_TABLE_INFO{$config_bit}{'min_y'}\n" .
        "WAFERMAP_MAX_Y: $::MOVE_TABLE_INFO{$config_bit}{'max_y'}\n" .
        "WAFERS_TO_PROBE: $num_waf\n" .
        "NUM_TOUCHDOWNS: $::MOVE_TABLE_INFO{$config_bit}{'num_steps'}\n";

    # used to instantiate handler in GPC, relies on equipment naming convention
    if ($prober =~ /(A090)|(A200)|(A300)|(A3EX)$/i) {
        $additional_information .= "HANDLER: ACCRETECH_UF\n";
    } elsif ($prober =~ /(TP012)$/i) {
        $additional_information .= "HANDLER: TEL_PROBER\n";
    } elsif ($prober =~ /(PREC)$/i) {
        $additional_information .= "HANDLER: TEL_PRECIO\n";
    }

    if ($::LOAD_PORT{$prober}{$cassette}{'batch_id'}) {
         $additional_information .= "BATCH_ID: $::LOAD_PORT{$prober}{$cassette}{'batch_id'}\n";
    }
    if (defined $::LOAD_PORT{$prober}{$cassette}{'run_id'}) {
         $additional_information .= "RUN_ID: $::LOAD_PORT{$prober}{$cassette}{'run_id'}\n";
    }
    else {
         $additional_information .= "RUN_ID: 00\n";
    }
    if (defined $::MOVE_TABLE_INFO{$config_bit}{config_num}) {
        $additional_information .= "MTCONFIG: $::MOVE_TABLE_INFO{$config_bit}{config_num}\n";
    }
    if ($::ET_ITEMS{$::TESTER_ID}{'HEADB'}) {
        $additional_information .= "HEADB: $::ET_ITEMS{$::TESTER_ID}{'HEADB'}{'value'}\n";
    }
    if ($::LOAD_PORT{$prober}{$cassette}{'trend'}) {
        $additional_information .=
            "NUM_TRENDED_WAFERS: $::LOAD_PORT{$prober}{$cassette}{'trend'}\n" .
            "TRENDING_FLAG: 1\n";
    }
    if ($::PROCESS_STEP{'StepCode'}) {
        $additional_information .=
            "STEP_CODE: $::PROCESS_STEP{'StepCode'}\n" .
            "STEP_DESC: $::PROCESS_STEP{'StepDesc'}\n" .
            "OPERATION_DESC: $::PROCESS_STEP{'OperationDesc'}\n";
    } else {
            "STEP_CODE: UNKNOWN\n" .
            "STEP_DESC: UNKNOWN\n" .
            "OPERATION_DESC: UNKNOWN\n";
    }
    # used by GPC for thermal management
    if ($::ET_ITEMS{$::TESTER_ID}{'child'}{$prober}{'PRB_CTEMP'}{'value'}) {
        my $previous_chuck_temperature = $::ET_ITEMS{$::TESTER_ID}{'child'}{$prober}{'PRB_CTEMP'}{'value'};
        if ( $previous_chuck_temperature =~ /^[+-]?\d+$/ ) {
            $additional_information .= "PREVIOUS_CHUCK_TEMPERATURE: $previous_chuck_temperature\n";
        }
    }
    if ($SiteConfig{'TempChangeStabilize'} == 1) {
        my $temperature_stabilization_time = CommonCfg::check_temp_stabilization_interrupt($prober);
        $additional_information .= "RESUME_TEMPERATURE_STABILIZATION: $temperature_stabilization_time\n" if $temperature_stabilization_time;
    }
    if ($::ET_ITEMS{$::TESTER_ID}{'ILLUMINATOR_SN'}) {
        $additional_information .=
            "ILLUMINATOR_SN: $::ET_ITEMS{$::TESTER_ID}{'ILLUMINATOR_SN'}{'value'}\n" .
            "ILLUMINATOR_MODEL_NO: $::ET_ITEMS{$::TESTER_ID}{'ILLUMINATOR_MODEL_NO'}{'value'}\n";
    }
    # used by wafmap
    my $job_rev = get_job_rev();
    $additional_information .= "VERSION: $job_rev\n" if $job_rev;
    # obtain x,y offsets for every tester site
    my $site_map_index = 0;
    my $probe_site = 0;
    my $probe_card_site = 0;
    my $tester_site;
    my %pc_site_delta_x;    # key is tester_site, value is x-offset
    my %pc_site_delta_y;    # key is tester_site, value is y-offset
    my %pc_site_delta_site; # key is tester_site, value is prober site
    my %probecard_delta_site; # key is tester_site, value is probecard site
    my (@site_map) = (split /\s/, $::MOVE_TABLE_INFO{$config_bit}{'site_map'});
    my $card_x = $::MOVE_TABLE_INFO{$config_bit}{'card_x'};
    my $card_y = $::MOVE_TABLE_INFO{$config_bit}{'card_y'};
    if (($card_x * $card_y) != scalar @site_map) {
       return("Expected " . ($card_x * $card_y) . " entries in move_table SITE_MAP, but encountered " . scalar @site_map);
    }
    for (my $card_row = 0; $card_row < $card_y; ++$card_row) {
       for (my $card_col = 0; $card_col < $card_x; ++$card_col) {
          $tester_site = $site_map[$site_map_index];
          if ($tester_site !~ m/x/i) {
             $pc_site_delta_x{$tester_site} = $card_col;
             $pc_site_delta_y{$tester_site} = $card_row;
             $pc_site_delta_site{$tester_site} = $probe_site;
             ++$probe_site;
          }
          ++$site_map_index;
       }

       # The probecard site numbering sequence is left to right and top to bottom vs. prober sites that is right to left and top to bottom.
       for (my $card_col_reverse = 1; $card_col_reverse <= $card_x; $card_col_reverse++) {
          $tester_site = $site_map[$site_map_index - $card_col_reverse];   # Subtract off the column index to reverse each row.
          if ($tester_site !~ m/x/i) {
             $probecard_delta_site{$tester_site} = $probe_card_site;
             ++$probe_card_site;
          }
       }
    }
    my $tester_site_string;
    my $prober_site_string;
    my $probecard_site_string;
    my $probecard_site_string2;
    my $x_offset_string;
    my $y_offset_string;
    foreach $tester_site (sort {$a <=> $b} keys %pc_site_delta_x) {
       if (!$tester_site_string) {
          $tester_site_string = "TESTER_SITE: $tester_site";
          $prober_site_string = "PROBER_SITE: $pc_site_delta_site{$tester_site}";
          $probecard_site_string = "PROBECARD_SITE: $probecard_delta_site{$tester_site}";
          $probecard_site_string2 = "PROBE_CARD_SITE: $probecard_delta_site{$tester_site}";
          $x_offset_string    = "X_OFFSET: $pc_site_delta_x{$tester_site}";
          $y_offset_string    = "Y_OFFSET: $pc_site_delta_y{$tester_site}";
       } else {
          $tester_site_string .= ",$tester_site";
          $prober_site_string .= ",$pc_site_delta_site{$tester_site}";
          $probecard_site_string .= ",$probecard_delta_site{$tester_site}";
          $probecard_site_string2 .= ",$probecard_delta_site{$tester_site}";
          $x_offset_string    .= ",$pc_site_delta_x{$tester_site}";
          $y_offset_string    .= ",$pc_site_delta_y{$tester_site}";
       }
    }
    $additional_information .=
        "$tester_site_string\n" .
        "$prober_site_string\n" .
        "$probecard_site_string\n" .
        "$probecard_site_string2\n" .
        "$x_offset_string\n" .
        "$y_offset_string\n";


    # this information is probably in $CARD_FILE, generated by sys_info
    # sys_info reads the card ID from NVRAM using utilities provided by SIG
    # then obtains information from PCT.  Some information comes from other
    # sources, and at least for the Illuminator Cal card is innacuurate
    # for this reason the relevant information is generated here
    $additional_information .=
        "PROBECARD_ID${handler}: $::PCARD_DATA{$prober}{'equip_id'}\n" .
        "PROBECARD_VENDOR${handler}: $::PCARD_DATA{$prober}{'vendor_name'}\n" .
        "PROBECARD_CONFIGURATION_BIT${handler}: $::PCARD_DATA{$prober}{'bit_config_id'}\n" .
        "PROBECARD_NAME${handler}: $::PCARD_DATA{$prober}{'probe_card_type_code'}\n" .
        "PROBECARD_X_PARALLELISM${handler}: $::PCARD_DATA{$prober}{'x_parallelism_no'}\n" .
        "PROBECARD_Y_PARALLELISM${handler}: $::PCARD_DATA{$prober}{'y_parallelism_no'}\n" .
        "MAX_OVERTRAVEL_UM${handler}: $::PCARD_DATA{$prober}{'max_overtravel_no'}\n" .
        "INITIAL_OVERTRAVEL_UM${handler}: $::PCARD_DATA{$prober}{'min_overtravel_no'}\n" .
        "PROBECARD_PLANARITY_LIM_UM${handler}: $::PCARD_DATA{$prober}{'max_planarity_no'}\n" .
        "PROBECARD_TOUCHDOWN_COUNT${handler}: $::PCARD_DATA{$prober}{'touchdown_count'}\n" .
        "CONTACT_SOAK_SECONDS${handler}: $::PCARD_DATA{$prober}{'contact_soak_seconds'}\n" .
        "PROBECARD_LENS_MODULE_EQUIP_ID${handler}: $::PCARD_DATA{$prober}{'child_lens_module_id'}\n";
    my $tester_sites = 0;
    foreach my $element (split /\s/, $::MOVE_TABLE_INFO{$config_bit}{'site_map'}) {
        if ($element !~ m/x/i) {
            ++$tester_sites;
        }
    }
    $additional_information .=
        "MACHINE_LB_SITES: $tester_sites\n";
    my $attribute_keyword;
    foreach my $attr_name ( sort keys %{$::PRB_PART_ATTR{$lot_id}})
    {
        $attribute_keyword = $attr_name;
        $attribute_keyword =~ s/\s/_/g;  # traveler does not want spaces in the keyword
        $additional_information .= "${attribute_keyword}: $::PRB_PART_ATTR{$lot_id}{$attr_name}\n";
    }
    ::notify('debug', "writing to $TMPTRAVL_FILE");
    if ( !defined($::OPT{'process_type'}) or ("NonProduct" ne $::OPT{'process_type'}) ) {
        write_file($TMPTRAVL_FILE, read_file($::LOAD_PORT{$prober}{$cassette}{'dlog_header'}));
    }
    elsif ( defined($::OPT{'process_type'}) and ($::OPT{'process_type'} eq "NonProduct") ) {
        $additional_information .=
            "PROCESS_ID: $::PROCESS_STEP{'pid'}\n" .
            "WAF_SIZE: 12\n" .
            "PART_TYPE: $::RECIPE{'PART_COMPATIBILITY'}\n";
    }

    append_file($TMPTRAVL_FILE, $additional_information);
    # Currently not available on C1D but the probecard file is available.
#    append_file($TMPTRAVL_FILE, read_file($TESTER_INFO_FILE));
    # see above for reasons why this is not being used
    append_file($TMPTRAVL_FILE, read_file($CARD_FILE));  # generated by sys_info
    append_file($TMPTRAVL_FILE, read_file($::LOAD_PORT{$prober}{$cassette}{'lot_attr_file'})) if $::LOAD_PORT{$prober}{$cassette}{'lot_attr_file'};
    if ($SiteConfig{'DirectedPMI'}) {
        my $pmi_info = CommonCfg::prepare_pmi_data($prober, $lot_id);
        if ( $::PROCESS_STEP{'ModeDesc'} eq 'PRODUCTION' and $pmi_info ) {
            append_file($TMPTRAVL_FILE, $pmi_info);
        }
    }
    return(undef);
}

# remove, then recreate the production path
sub pre_start_check {
    if ($::OPT{'offline'}) {   # Added this to avoid errors in offline mode
       return (undef);
    }
    if (scalar getpwuid($<) ne $PRODUCTION_USER) {
        # note, non-localized
        return("only user '$PRODUCTION_USER' should start lots on this system");
    } elsif (-e $PRODUCTION_DIR) {
#        eval { rmtree($PRODUCTION_DIR, 0, 0) };
#        if ($@) {
#            # note, non-localized
#            return("Error removing $PRODUCTION_DIR: $@");
#        }
#        unlink("$PRODUCTION_DIR/*");
#        unlink("$PRODUCTION_DIR/.*");
        `/bin/rm -rf $PRODUCTION_DIR/*`;
        `/bin/rm -rf $PRODUCTION_DIR/.[A-Za-z0-9_]*`;
    }
    eval { mkpath($PRODUCTION_DIR, 0, 0777) };
    if ($@) {
        # note, non-localized
        return("Error creating $PRODUCTION_DIR: $@");
    } else {
        return(undef);
    }
}

sub confirm_settings {
    return(undef);
}

# this can be used for platform specific menu customization
sub custom_menu {
    # limit the amount of options displayed in the Engineering Request List
    # Note: this is a platform specific customization, normally all options
    # listed in localization variable %PrbLocale::EngrRequest are displayed
    my @engr_request_options = ('CORR', 'EXPERIMENT', 'DEBUG');
    main::tk_configure_options('request_list', @engr_request_options);
    &main::MainLoop;
}

#sub run_selector {
#    my ($tmptravl, $macro) = @_;
#    my $system_command = "$SELECTOR -i $tmptravl $macro -k $MACRO_PATH";
#    print "$system_command\n" if $::DEBUG_MODE;
#    my $standard_output = `$system_command`;
#    if ($?) {
#        return("SystemCommand='$system_command' Fail: (" . ($? >> 8) . ") $standard_output");
#    } else {
#        return(undef);
#    }
#}

#sub selected_heads_merge {
#    my ($tmptravl) = @_;
#    my $system_command = "$SELECTED_HEADS_MERGE $tmptravl first";
#    my $standard_output = `$system_command`;
#    if ($?) {
#        return("SystemCommand='$system_command' Fail: (" . ($? >> 8) . ") $standard_output");
#    } else {
#        return(undef);
#    }
#}

# this logic was copied from IP750 Illuminator calibration
# I don't agree with sending non wafer data up to DFS using a
# fake LotID.  Perhaps the data can be sent direct to EngSPC
# or another system.  This uses the Old style LotID format
# which should be deprecated
sub generate_fake_lot_id {
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime(time());
    my @days = (qw (S M T W H F A));
    my $site_code;
    if ($::OPT{'site'} =~ m/NISHIWAKI/i) {
        $site_code = '0';
    } elsif ($::OPT{'site'} =~ m/IMFS/i) {
        $site_code = '10';
    } elsif ($::OPT{'site'} =~ m/LEHI/i) {
        $site_code = '2';
    }elsif ($::OPT{'site'} =~ m/BOISE/i) {
        $site_code = '3';
    } elsif ($::OPT{'site'} =~ m/MANASSAS/i) {
        $site_code = '6';
    } elsif ($::OPT{'site'} =~ m/TECH_SINGAPORE/i) {
        $site_code = '7';
    } elsif ($::OPT{'site'} =~ m/AVEZZANO/i) {
        $site_code = '9';
    } else {
        $site_code = '1';
    }
    my $day_code = $days[$wday];
    return(sprintf("99%s%02d%02d.%s11", $site_code, $hour, $min, $day_code));
}

sub test_job_pre_start_check {
    my $pre_start_script = "$::LOCAL_JOB_PATH/pre_start_check.pl";
    if (-e $pre_start_script) {
       main::notify('info', "calling Test Job pre-start check");
       eval read_file($pre_start_script);
       if ($@) {
          return($@);
       }
    }
    return(undef);
}

sub get_job_rev {
    my ($job_name) = @_;
    my $job_rev;
    # Old Flash code testers (pre New Coding Standard )
    
    my ( $pln_file, $job_rev );    
    if ( -e ($pln_file = File::Spec->catfile($PRODUCTION_DIR, "jobInfo.pln")) ) {
        (undef, $job_rev) = get_software_version($pln_file, 'JOB_REV:');
    }
    elsif( -e ($pln_file = File::Spec->catfile($PRODUCTION_DIR, "JobVersion.asc"))  ) {
    (undef, $job_rev) = get_software_version($pln_file, 'PROGRAM_REVISION:');
    }    
    return($job_rev) if $job_rev;
}

sub get_software_version {
    my ($version_file, $rev_keyword) = @_;
    my $version;
    my $job_rev;
    my $line;
    my $keyword;
    my $value;
    if (open(VERSION_FILE, "<$version_file"))
    {
        while ($line = <VERSION_FILE>) {
            if (($keyword, $value) = $line =~ /^\s*(\S+)\s+(\S+)\s*$/) {
                if ($keyword =~ /TESTER_VERSION/i) {
                    $version = $value;
                } elsif ($keyword =~ /$rev_keyword/i) {
                    $job_rev = $value;
                }
            } elsif (($value) = $line =~ /^\s*(\S+)\s*$/) {
                $version = $value;
            }
        }
        close (VERSION_FILE);
    }
    return($version, $job_rev);
}

#####################################################################################
# write_swr_groupfile
#####################################################################################
#  This function wrties the swr_group_file ( see FORMAT below ).  It will first look for existence of the  probe wafer level attribute: SWR SPLIT GROUP NO
#    PARAMATERS:
#           $lot  -- Full 7.3 lotnumber
#           $PRB_LOT_ATTR{lot}{lot}  =  {                            #  Hashref format
#                    'SWR FINAL HOLD' => 'NO',
#                   'SWR FLAG' => 'YES',
#                   'SWR LEVEL NAME' => 'NONE',
#                   'SWR PREFUSE HOLD' => 'NO',
#                   'SWR PREGLASS HOLD' => 'NO',
#           }
#
#    $PRB_WAFER_ATTR{lot}  = {                                  # Hashref format
#                                   '4932-01' => {
#                                                'DFS DISPO FUNC SCRAP' => 'NO SCRAP',
#                                                'DFS_DISPO_HOLD' => 'RELEASED',
#                                     }
#       }
#
#  OUTPUT FILE FORMAT: --  Wafer: GroupNumber   with one line written per wafer.
# -----------------
# 4932-01: 1
#4932-02: 2
#4932-03: 4
#4932-04: 4
#4932-05: 5
#4932-06: 1
#4932-07: 1
#4932-08: 3
#4932-09: 2
#4932-10: 4
#4932-11: 9
#.....
sub write_swr_groupfile {
    my ( $lot, $prb_lot_attr_href, $prb_wfr_attr_href ) = @_;

    # First check for the SWR SPLIT GROUP NO attribute
    my $split_groups_href = {};     # Keyed by group  {Group_Number}->( wafer1, wafer2, wafer3 )
    my $found_swr_groups = 0;
    foreach my $wafer ( keys %$prb_wfr_attr_href ) {

        if ( exists $prb_wfr_attr_href->{$wafer}{'SWR SPLIT GROUP NO'} ) {
            $found_swr_groups++;
            my $group = $prb_wfr_attr_href->{$wafer}{'SWR SPLIT GROUP NO'};
            push @{ $split_groups_href->{$group}}, $wafer;

        }
    }
    if ( ! scalar keys %$split_groups_href ) {
        main::notify('debug', "WARN: No SWR split group data found -- even though attribute SWR FLAG was set");
        return;              #  We don't want to have menu error out currently, so we just return no error
    }
    my $swr_group_file = File::Spec->catfile( $PlatformCfg{'AttrDir'}, 'swr_split_groups_hd0.dat');
    my $swr_group_fh;
    if ( !open ( $swr_group_fh, '>', $swr_group_file ) ) {
        main::notify('debug', "WARN: Unable to write SWR split group file: $swr_group_file - $!");
        return;
   }
    main::notify('debug', "Writing SWR group file: $swr_group_file");
    foreach my $group ( sort {$a<=>$b} keys %$split_groups_href ) {
        foreach my $wafer ( sort @{ $split_groups_href->{$group}} ) {
           print $swr_group_fh "$wafer: $group\n";
        }
    }
    close $swr_group_fh;
    return;                  # Dont' want to return anything, as a true value represents an error

}

sub start_probecard_heater {
    my $keyword_num;

    if ( $ENV{'HOST'} !~ /c1d/i ) {
       return;
    }
    #  Remove the previous status file in case it is out dated or stale.
    my $status_log = '/var/tmp/heater_status.log';
    system("/bin/unlink $status_log") if -e $status_log;

    if (0 > $::TEMPERATURE) {
        $keyword_num = 0;
    }
    elsif ( (0 <= $::TEMPERATURE) && (40 > $::TEMPERATURE) ) {
        $keyword_num = 1;
    }
    elsif ( (40 <= $::TEMPERATURE) && (80 > $::TEMPERATURE) ) {
        $keyword_num = 2;
    }
    elsif ( (80 <= $::TEMPERATURE) && (115 > $::TEMPERATURE) ) {
        $keyword_num = 3;
    }
    elsif (115 <= $::TEMPERATURE) {
        $keyword_num = 4;
    }
    my $set_point = -1;
    my $overshoot = -1;
    my $soak_time = -1;
    my $upper_guardband = 5;
    my $lower_guardband = 5;
    my $heater_command;

    main::notify('debug', "start_probecard_heater: temp=$::TEMPERATURE keyword_num=$keyword_num");
    foreach my $prober (sort keys %::LOAD_PORT)
    {
        if (defined($::PCARD_DATA{$prober}{"PC_HTR_".$keyword_num."_SETPOINT_DEGREES"})) {
            $set_point =  $::PCARD_DATA{$prober}{"PC_HTR_".$keyword_num."_SETPOINT_DEGREES"};
        }
        if (defined($::PCARD_DATA{$prober}{"PC_HTR_".$keyword_num."_OVERSHOOT_DEGREES"})) {
            $overshoot =  $::PCARD_DATA{$prober}{"PC_HTR_".$keyword_num."_OVERSHOOT_DEGREES"};
        }
        if (defined($::PCARD_DATA{$prober}{"PC_HTR_".$keyword_num."_SOAK_SECONDS"})) {
            $soak_time =  $::PCARD_DATA{$prober}{"PC_HTR_".$keyword_num."_SOAK_SECONDS"};
        }
        if (defined($::PCARD_DATA{$prober}{"PC_HTR_UPPER_GUARDBAND"})) {
            $upper_guardband =  $::PCARD_DATA{$prober}{"PC_HTR_UPPER_GUARDBAND"};
        }
        if (defined($::PCARD_DATA{$prober}{"PC_HTR_LOWER_GUARDBAND"})) {
            $lower_guardband =  $::PCARD_DATA{$prober}{"PC_HTR_LOWER_GUARDBAND"};
        }
    }
    main::notify('debug', "start_probecard_heater: set_point=$set_point overshoot=$overshoot soak_time=$soak_time");

    if ( ($set_point == -1) && ($overshoot == -1) && ($soak_time == -1) ) {  # Do nothing if there are no values
        return;
    }
    elsif ( ($set_point == 0) && ($overshoot == 0) && ($soak_time == 0) ) {  # Turn heater off per JHUNTER
        $heater_command = "/u/probe/bin/card_heater_control -stop";
    }
    else {
        $heater_command = "/u/probe/bin/card_heater_control -monitor -set_point=$set_point -over_shoot=$overshoot -soak_time=$soak_time -upper_guardband=$upper_guardband -lower_guardband=$lower_guardband";
    }
    main::notify('debug', "start_probecard_heater: $heater_command");
    my $heater_start = "$MANAGE_SINGLETON restart card_heater_control '$heater_command' &";
    system($heater_start);
}

sub run_autoRXcal
{
   my $rxcal_args = "";

   foreach my $prober (sort keys %::LOAD_PORT) {
      if ( defined($::PCARD_DATA{$prober}{'RXCAL_ARGS'}) ) {
         $rxcal_args = lc($::PCARD_DATA{$prober}{'RXCAL_ARGS'});
      }
   }
   if ( $ENV{'HOST'} =~ /c1d0/i ){
      my $rxcal_ret = 0;
      if (-e "/opt/sttsw/current/python/autoRXcal.pyc") {
         $rxcal_ret = system("sigpython /opt/sttsw/current/python/autoRXcal.pyc $rxcal_args");
         main::notify('log', "sigpython /opt/sttsw/current/python/autoRXcal.pyc $rxcal_args");
      } else {
         $rxcal_ret = system("sigpython /opt/sttsw/current/python/autoRXcal.py $rxcal_args");
         main::notify('log', "sigpython /opt/sttsw/current/python/autoRXcal.py $rxcal_args");
      }
      if ($rxcal_ret) {
         return("RXcal has failed, please contact Equipment Support");
      }
   }
   return(undef);
}

1;  # return value for module
